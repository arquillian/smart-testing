== Jenkins

So far you've seen how to use Smart Testing from developer perspective (running on local machine).
But ultimately your software is going to be built on CI/CD server and saving time there means more resources for other projects.

One of important things to take into consideration is that meanwhile in developer's machine `selecting` mode might be the most used one, in CI/CD server you *must* run always the build in `ordering` mode.
You can read more about modes at <<Modes>> section.

Also it is important to set correctly the commit range.
In case of development machine, you'll probably want to just take into consideration the local changes, but in case of CI/CD environment, then probably the changes you want to take into consideration are those between the commits you are going to run the build.

Let's see how to configure Smart Testing in Jenkins.

=== Jenkins Freestyle project

Freestyle project is the old way of creating pipelines with Jenkins.
To use Smart Testing in this kind of projects, you only need to create a build step of kind `Execute Shell`/`Execute Windows batch command` running Maven with required Smart Testing configuration parameters.


[source, subs="attributes, macros"]
----
mvn -Dconst:core/src/main/java/org/arquillian/smart/testing/Configuration.java[name="SMART_TESTING"]="new, affected"
    -Dconst:core/src/main/java/org/arquillian/smart/testing/Configuration.java[name="SMART_TESTING_MODE"]=ordering
    -Dconst:core/src/main/java/org/arquillian/smart/testing/scm/ScmRunnerProperties.java[name="COMMIT"]=${GIT_COMMIT}
    -Dconst:core/src/main/java/org/arquillian/smart/testing/scm/ScmRunnerProperties.java[name="PREVIOUS_COMMIT"]=${GIT_PREVIOUS_COMMIT}
    test
----

In next figure you can see the step configuration.

.Freestyle Execute Shell Configuration
image::st-freestyle.png[]

After that you can run the build.
What you will notice in this case is that since the configured mode is `ordering`, all tests are going to be executed first, but the ones marked as important by `new` and `affected` strategies are executed first.

=== Jenkins Pipeline

Jenkins Pipeline is a group of plugins which supports implementing and integrating continuous delivery pipelines into Jenkins.
The definition of a Jenkins Pipeline is typically written into a text file (called a `Jenkinsfile`) which in turn is checked into a projectâ€™s source control repository

To run Smart Testing in Jenkins Pipeline you need to manually call `checkout scm` process manually to get access to `GIT_COMMIT` and `PREVIOUS_GIT_COMMIT` variables.
This might not be a problem if you are using scripted pipeline but one in case of using declarative pipeline since the checkout process is done automatically hence no access to `GIT_COMMIT` and `PREVIOUS_GIT_COMMIT` variables.

So in next snippet you can see an example on how to use declarative pipeline with Smart Testing:

[source, subs="macros"]
.Jenkinsfile
----
pipeline {
    options {
        skipDefaultCheckout()
    }
    agent any
    stages {
        stage('Compile and Test') {
            steps {
                script {
                    def scmVars = checkout scm
                    sh "mvn -Dconst:core/src/main/java/org/arquillian/smart/testing/Configuration.java[name="SMART_TESTING"]='new, affected' -Dconst:core/src/main/java/org/arquillian/smart/testing/Configuration.java[name="SMART_TESTING_MODE"]=ordering -Dconst:core/src/main/java/org/arquillian/smart/testing/scm/ScmRunnerProperties.java[name="COMMIT"]=${scmVars.GIT_COMMIT} -Dconst:core/src/main/java/org/arquillian/smart/testing/scm/ScmRunnerProperties.java[name="PREVIOUS_COMMIT"]=${scmVars.GIT_PREVIOUS_COMMIT} test"
                }
            }
            post {
                success {
                    junit 'target/surefire-reports/**/*.xml'
                }
            }
        }
    }
}
----

In previous `Jenkinsfile`, you are using declarative script approach.
First of all you need to disable automatic checkout.
It is important to note that this is only required if you are using declarative approach.
Then you need to manually call checkout and store the result into variable.
Finally you can call Maven, getting Git parameters from `scmVars`.
